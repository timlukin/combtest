f_1, ..., f_N - тестовые факторы
L_i - мощность домена f_i
{l_i_1, ... l_i_{L_i}} - домен f_i
R - тестовый набор

A: 0, 1
B: 0, 1
C: 0, 1, 2
AB - 4 слота
AC - 6 слотов
BC - 6 слотов
Каждый слот - uncovered, covered или excluded.
слота подходит под ограничение (constraint) => excluded
Нет uncovered => закончить

Алгоритм - жадный, эвристический. 1 случай за раз, локальная оптимизация. Похоже на алгоритм в AETG.

Если еще остались, берем заранее заднный тестовый набор (seed combination), помечаем все покрытые им слоты. Добавляем их в набор. НЕ ОБЯЗАТЕЛЬНО, чтобы тестовые наборы были полными: достаточно указать значения некоторых параметров.

Далее с кейсом r_i: пока он не заполнен:
  Если он пустой, то взять самый жирный слот (с максимальным количеством неиспользованных параметров) и пихнуть его в тест
  Если он непуст, то предположим, что параметры l_1, ..., l_{k-1} выбраны. Находим подмножество слотов, которые содержат какой-нить параметр кроме f_1, ..., f_{k-1} и консистентны со значениями l_1, ..., l_{k-1}.
...  дальше по тексту proto_alg.py

Ограничения - набор комбинаций, которые нельзя использовать.
Как ловить ограничения на большее количество параметров, чем размеры слотов.

Ограничения как лямбды. Парсим сигнатуру и скармливаем параметры. Остальные - в виде логических выражений с импликациями.
Часть ограничений (те, сигнатура которых входит в слоты) фигачим на слоты изначально (выкидываем и слоты и ограничения).


Запись логов: чтобы показать что и как.


Ограничения при предподсчете параметров и килл при слишком долгом выполнении.

Возможно, для обхождения массивных ограничений, требуется использовать слоты с сигнатурой ограничений.


Важно помнить: в процессе генерации непомеченные слоты могут быть частично связаны с огранчениями, связанными с уже нагенеренными данными.
A B C
0 . .
1 . .
. 0 .
. 1 .
. . 0
. . 1

A B C
- 0 0 0
0 0 1
0 1 0
0 1 1
1 0 0
1 0 1
1 1 0
1 1 1

Ограничение есть в A B C => ограничение есть в A B.
Когда добавляем ограничение из A B C, следим, чтобы они покрыли максимум непокрытых комбинаций.
То есть при построении ограничения A B C, требуется взвесить наборы на тему покрываемых комбинаций (unfitting_level в proto_alg.py)

